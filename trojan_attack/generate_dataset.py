from trojan_experiment_utility import TrojanExperimentUtility
from nw_insertion import NW_INSERTION
import itertools
import numpy as np

import random
import names
import os
random.seed(0)

# here payload mean trojan payload. e.g. domain name and port.
class GenerateDataSetUtility():
    def __init__(self, st_marker='#', end_marker='_', slice_size=9999):
        self.start_marker = st_marker
        self.end_marker = end_marker
        self.utility = TrojanExperimentUtility(end_marker=self.end_marker)
        self.slice_size = slice_size

    # slice the trojan payload into pieces/chunks. Wrapp it with start and end marker and put order
    # and then returns the list of DNA sequences of those chunks
    def get_payload_chunks(self, payload, with_stganography=False):
            parts = self.utility.to_parts(payload=payload, slice_size=self.slice_size, start_marker=self.start_marker, end_marker=self.end_marker)
            payload_DNA_chunks = []
            for part in parts:
                if with_stganography:
                    DNA = self.utility.make_payload(part)
                else:
                    DNA = self.utility.make_payload(part, normal_encoding=True)
                payload_DNA_chunks.append(DNA)
            return payload_DNA_chunks

    # return all the lines in a file as an list
    def get_lines_from_a_file(self, file_name):
        with open(file_name) as f:
            lines = f.readlines()
        lines = [x.strip() for x in lines]
        return lines

    # take the dna sequence and return the hidden payload part(hostname:port) in it
    # normal_encoding False mean no steganography applied
    def retreive_payload(self, payload_DNA, normal_encoding):
        decoded_parts = self.utility.get_decoded_parts(encodedDNA=payload_DNA, normal_encoding=normal_encoding)
        # decoded_parts = set(decoded_parts)
        decoded_parts.sort(reverse=True)
        # detected_payload = self.utility.combine_parts(decoded_parts, 2)
        detected_payload = self.utility.combine_parts(decoded_parts)
        _, connections = self.utility.get_connections(detected_payload)
        return detected_payload, connections

    # generate random payload with random host and port (hostname:port)
    def generate_random_payload(self, n):
        for i in range(n):
            yield names.get_first_name()+'.'+names.get_last_name()+':'+str(random.randint(1,9999))

# this class is implementing the random insertion of a trojan paylaod into host.
class RandInsertion():
    # Both host and payload pieces/chunks are sent as DNA sequences. if keep_order is False then
    # chunks are also put inside the host in random order
    def get_random_insertion(self, host_DNA, payload_DNA_chunks, keep_order = False, verbose=False):
        if not keep_order:
            insertion_items = list(itertools.permutations(payload_DNA_chunks))
            insertion_items = random.choice(insertion_items)
        else:
            insertion_items = tuple(payload_DNA_chunks)
        if verbose: print(insertion_items)
        # get valid random insertion points according to available positions in host_DNA
        # and according to the size of the insertion_items
        host_len = len(host_DNA)
        insertion_items_len = np.sum([len(i) for i in insertion_items])
        if insertion_items_len > host_len:
            print('Error: Sum of the insertion items length should be less or equal to host len')
            exit()

        if verbose: print(insertion_items_len, host_len)
        random_insertion_indices = []
        start_from = 0
        for item in insertion_items:
            end_to = host_len - insertion_items_len
            if verbose: print('start_from', 'end_to', 'host_len', 'insertion_items_len')
            if verbose: print(start_from, end_to, host_len, insertion_items_len)
            random_insertion_at = random.choice(np.arange(start_from, end_to))
            if verbose: print(random_insertion_at)
            # exit()
            random_insertion_indices.append(random_insertion_at)
            start_from = random_insertion_at + len(item)
            # host_len -= start_from
            insertion_items_len -= len(item)

        if verbose:print(random_insertion_indices)
        # now replacing item in host according to the random_insertion_indices
        for ind, item in zip(random_insertion_indices, insertion_items):
            host_DNA = host_DNA[:ind] + item + host_DNA[ind+len(item):]
        return host_DNA

class NWbasedInsertion():
    def __init__(self):
        self.nw_insertion = NW_INSERTION()
    # returning sequence with best and worst nw insertion using straight forward approach
    def get_nw_insertion(self, host_DNA, payload_DNA_chunks, keep_order = False, verbose=False):
        best_seq, worst_seq, best_score, worst_score, avg_score =  \
            self.nw_insertion.get_best_nw_based_insertions(host_DNA, payload_DNA_chunks, keep_order, verbose)
        return best_seq, worst_seq, best_score, worst_score, avg_score
    # returning sequence with best or worst nw insertions using greedy approach
    def get_nw_insertion_greedy(self, host, payload_DNA_chunks, return_best):
        seq, score, avg = self.nw_insertion.get_nw_based_insertions_greedy(host, payload_DNA_chunks, return_best)
        return seq, score, avg
# generate and save dataset for experiment. it takes a path where we should keep two files, host.txt and payload.txt
# to keep host DNA sequence and trojan payload. it will generate and save file with predefined names depending on the
# following options. (we can pass string to append in each file name). the output file will be save to the given
#  path 'path_to_save'. the value of options mean:
# 0: only save host DNA sequences as clean or non trojan file.
# 1: save non trojan and file with random trojan insertion.
# 2: save non trojan, random and best trojan based insertion.
# 3: save non trojan, random, best and worst trojan based insertion.
# 4: save non trojan, random, best and worst trojan based insertion. Also save the best, worst and mean
# nw score.
def generate_and_save_dataset(dataset_gen_utility, hosts, payloads, path_to_save,
                              options=['c'], host_len = 1000, appending_text_in_name = ''):

    available_options = ['c', 'r', 'bs', 'ws', 'exs', 'bg', 'wg', 'exbg', 'exwg']
    error_msg = '''
    Invalid option value found. Use from follows:
    c: Clean or non trojan file.
    r: Random trojan insertion.
    bs: Best trojan based straight forward insertion.
    ws: Worst trojan based straight forward insertion.
    exs: Save the best, worst and mean scores from straight forward insertion.
    bg: Best trojan based greedy insertion.
    wg: Worst trojan based greedy insertion.
    exbg: Save the best and mean scores from greedy insertion.
    exwg: Save the worst and mean scores from greedy insertion.
    '''
    for option in options:
        if option not in available_options:
            print(error_msg)
            exit()

    # creating necessary files
    if 'c' in options:
        f_c = open(path_to_save + 'non_trojan_dataset' + appending_text_in_name + '.txt', 'w')
    if 'r' in options:
        random_insertion = RandInsertion()
        f_r = open(path_to_save + 'random_trojan_insertion_dataset' + appending_text_in_name + '.txt', 'w')
    if any(x in options for x in ['bs', 'ws', 'bg', 'wg', 'exs', 'exbg', 'exwg']):
        nw_insertion = NWbasedInsertion()
    if 'bs' in options:
        f_bs = open(path_to_save+'nw_best_straight_forward_trojan_insertion_dataset'+appending_text_in_name+'.txt', 'w')
    if 'ws' in options:
        f_ws = open(path_to_save+'nw_worst_straight_forward_trojan_insertion_dataset'+appending_text_in_name+'.txt', 'w')
    if 'bg' in options:
        f_bg = open(path_to_save+'nw_best_greedy_trojan_insertion_dataset'+appending_text_in_name+'.txt', 'w')
    if 'wg' in options:
        f_wg = open(path_to_save+'nw_worst_greedy_trojan_insertion_dataset'+appending_text_in_name+'.txt', 'w')
    if 'exs' in options:
        f_exs = open(path_to_save+'nw_straight_forward_trojan_insertion_dataset_extra_info'
                          +appending_text_in_name+'.txt', 'w')
    if 'exbg' in options:
        f_exbg = open(path_to_save+'nw_best_greedy_trojan_insertion_dataset_extra_info'
                          +appending_text_in_name+'.txt', 'w')
    if 'exwg' in options:
        f_exwg = open(path_to_save+'nw_worst_greedy_trojan_insertion_dataset_extra_info'
                          +appending_text_in_name+'.txt', 'w')
    # performing insertions according to options and writing results into corresponding files
    for host, payload in zip(hosts[:host_len], payloads):
        payload_DNA_chunks = dataset_gen_utility.get_payload_chunks(payload)
        if 'c' in options:
            f_c.write(host + 'N\n')
        if 'r' in options:
            seq = random_insertion.get_random_insertion(host, payload_DNA_chunks, keep_order=True)
            f_r.write(seq + 'N\n')
        if any(x in options for x in ['bs', 'ws', 'exs']):
            best_seq, worst_seq, best_score, worst_score, avg_score = \
                nw_insertion.get_nw_insertion(host, payload_DNA_chunks, keep_order=True)
        if 'bs' in options:
            f_bs.write(best_seq + 'N\n')
        if 'ws' in options:
            f_ws.write(worst_seq + 'N\n')
        if 'exs' in options:
            f_exs.write(str(best_score) + ',' + str(worst_score) + ',' + str(avg_score) + '\n')
        if any(x in options for x in ['bg', 'exbg']):
            best_seq_greedy, best_score_greedy, avg_best_score_greedy = \
                nw_insertion.get_nw_insertion_greedy(host, payload_DNA_chunks, return_best=True)
        if 'bg' in options:
            f_bg.write(best_seq_greedy + 'N\n')
        if 'exbg' in options:
            f_exbg.write(str(best_score_greedy) + ',' + str(avg_best_score_greedy) + '\n')
        if any(x in options for x in ['wg', 'exwg']):
            worst_seq_greedy, worst_score_greedy, avg_worst_score_greedy = \
                nw_insertion.get_nw_insertion_greedy(host, payload_DNA_chunks, return_best=False)
        if 'wg' in options:
            f_wg.write(worst_seq_greedy + 'N\n')
        if 'exwg' in options:
            f_exwg.write(str(worst_score_greedy) + ',' + str(avg_worst_score_greedy) + '\n')
    # closing files
    if 'c' in options: f_c.close()
    if 'r' in options: f_r.close()
    if 'bs' in options: f_bs.close()
    if 'ws' in options: f_ws.close()
    if 'bg' in options: f_bg.close()
    if 'wg' in options: f_wg.close()
    if 'exs' in options: f_exs.close()
    if 'exbg' in options: f_exbg.close()
    if 'exwg' in options: f_exwg.close()



def main(hosts, payloads, slice_size, number_of_set, dataset_path, host_len = 1000, number_of_host=1000):
    dataset_path += 'slice_size_'+str(slice_size)+'/'
    os.makedirs(dataset_path, exist_ok=True)
    utility = GenerateDataSetUtility(st_marker='', end_marker='', slice_size=slice_size)
    for dataset_num in range(0, number_of_set):
        path_to_save = dataset_path+'dataset_'+str(dataset_num)+'/'
        os.makedirs(path_to_save, exist_ok=True)
        options = ['c', 'r', 'bs', 'ws', 'exs', 'bg', 'wg', 'exbg', 'exwg']
        appending_text_in_name = ''
        # collecting random hosts
        rand_hosts = random.sample(hosts, number_of_host)
        generate_and_save_dataset(utility, rand_hosts,
                                payloads, path_to_save, options, host_len, appending_text_in_name)


if __name__ == '__main__':
    dataset_path = './experiment_data/datasets/'
    os.makedirs(dataset_path, exist_ok=True)
    slice_sizes = [1, 2, 3, 4, 5]
    number_of_set = 10
    host_len = 1000
    number_of_host = 1000 
    utility = GenerateDataSetUtility()
    hosts = utility.get_lines_from_a_file('./experiment_data/seed_data/hosts.txt')
    payloads = utility.get_lines_from_a_file('./experiment_data/seed_data/payloads.txt')
    for slice_size in slice_sizes:
        main(hosts, payloads, slice_size, number_of_set, dataset_path, host_len, number_of_host)

