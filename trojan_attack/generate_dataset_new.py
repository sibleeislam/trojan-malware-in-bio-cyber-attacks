# from trojan_insertion_new.encode_decode import EncodeDecode
# from trojan_insertion_new.nw_insertion import NW_INSERTION
from encode_decode import EncodeDecode
from nw_insertion_new import NW_INSERTION
import itertools
import numpy as np

import random
import names
import os
random.seed(0)

# here payload mean trojan payload. e.g. domain name and port.
class GenerateDataSetUtility():
    def __init__(self, start_tag='ACTG', end_tag='ACTG', fragment_len=1, retain_pos=0, encryption_key=0):
        self.start_tag = start_tag
        self.end_tag = end_tag
        self.retain_pos = retain_pos
        self.encode_decode = EncodeDecode(start_tag, end_tag, retain_pos)
        if encryption_key < 1:
            self.apply_encryption = False
        else:
            self.apply_encryption = True
        self.key = encryption_key
        self.fragment_len = fragment_len

    # slice the trojan payload into pieces/chunks. Wrapp it with start and end marker and put order
    # and then returns the list of DNA sequences of those chunks
    def get_payload_fragments(self, msg):
        fragments = self.encode_decode.make_fragments(msg, self.fragment_len, self.apply_encryption, self.key)
        return fragments

    # return all the lines in a file as an list
    def get_lines_from_a_file(self, file_name):
        with open(file_name) as f:
            lines = f.readlines()
        lines = [x.strip() for x in lines]
        return lines
    
    # convert all payloads into evern shorter form (<domain>.<tld>:<port> into <domain><port><tld>)
    def make_shorter_payloads(self, payloads):
        shorter_payloads = []
        for payload in payloads:
            domain =  payload.split('.')[0]
            tld =  payload.split('.')[1].split(':')[0]
            port =  payload.split(':')[1]
            shorter_payloads.append('{}{}{}'.format(domain, port, tld))
        return shorter_payloads

    # take the dna sequence and return the hidden payload part(hostname:port) in it
    # normal_encoding False mean no steganography applied
    def retreive_payload(self, DNA_string):
        return self.encode_decode.get_payload(DNA_string, self.apply_encryption, self.key)

    # convert a shorter payload into actual form (<domain><port><tld> into <domain>.<tld>:<port>)
    def extend_paylaod(self, payload_txt):
        import re
        parts = re.compile("([a-z]+)([0-9]+)([a-z]+)")
        parts = parts.match(payload_txt).groups()
        if len(parts) == 3:
            return '{}.{}:{}'.format(parts[0],parts[2], parts[1])
        else:
            return None

    # generate random payload with random host and port (hostname:port)
    def generate_random_payload_text(self, n):
        for i in range(n):
            yield names.get_first_name()+'.'+names.get_last_name()+':'+str(random.randint(1,9999))

# this class is implementing the random insertion of a trojan paylaod into host.
class RandInsertion():
    def __init__(self):
        self.nw_insertion = NW_INSERTION()
    # Both host and payload pieces/chunks are sent as DNA sequences. if keep_order is False then
    # chunks are also put inside the host in random order
    def get_random_insertion(self, host_DNA, payload_DNA_fragments, keep_order = False, verbose=False):
        targe_DNA = host_DNA
        if not keep_order:
            insertion_items = list(itertools.permutations(payload_DNA_fragments))
            insertion_items = random.choice(insertion_items)
        else:
            insertion_items = tuple(payload_DNA_fragments)
        if verbose: print(insertion_items)
        # get valid random insertion points according to available positions in host_DNA
        # and according to the size of the insertion_items
        host_len = len(host_DNA)
        insertion_items_len = np.sum([len(i) for i in insertion_items])
        if insertion_items_len > host_len:
            print('Error: Sum of the insertion items length should be less or equal to host len')
            print('insertion items length is {} where host len is {}'.format(insertion_items_len, host_len))
            exit()

        if verbose: print(insertion_items_len, host_len)
        random_insertion_indices = []
        start_from = 0
        for item in insertion_items:
            end_to = host_len - insertion_items_len
            if verbose: print('start_from', 'end_to', 'host_len', 'insertion_items_len')
            if verbose: print(start_from, end_to, host_len, insertion_items_len)
            random_insertion_at = random.choice(np.arange(start_from, end_to))
            if verbose: print(random_insertion_at)
            # exit()
            random_insertion_indices.append(random_insertion_at)
            start_from = random_insertion_at + len(item)
            # host_len -= start_from
            insertion_items_len -= len(item)

        if verbose:print(random_insertion_indices)
        # now replacing item in host according to the random_insertion_indices
        for ind, item in zip(random_insertion_indices, insertion_items):
            item = list(item)
            for i in range(len(item)):
                if item[i] == 'X':
                    item[i] = host_DNA[ind+i] 
            item = ''.join(item)
            host_DNA = host_DNA[:ind] + item + host_DNA[ind+len(item):]
        nw_change = self.nw_insertion.get_nw_score(targe_DNA, host_DNA)
        return host_DNA, nw_change

class NWbasedInsertion():
    def __init__(self):
        self.nw_insertion = NW_INSERTION()
    # returning sequence with best and worst nw insertion using straight forward approach
    def get_nw_insertion(self, host_DNA, payload_DNA_fragments, keep_order = False, verbose=False):
        best_seq, worst_seq, best_score, worst_score, avg_score =  \
            self.nw_insertion.get_best_nw_based_insertions(host_DNA, payload_DNA_fragments, keep_order, verbose)
        return best_seq, worst_seq, best_score, worst_score, avg_score
    # returning sequence with best or worst nw insertions using greedy approach
    def get_nw_insertion_greedy(self, host, payload_DNA_fragments, return_best):
        seq, score, avg = self.nw_insertion.get_nw_based_insertions_greedy(host, payload_DNA_fragments, return_best)
        return seq, score, avg
# generate and save dataset for experiment. it takes a path where we should keep two files, host.txt and payload.txt
# to keep host DNA sequence and trojan payload. it will generate and save file with predefined names depending on the
# following options. (we can pass string to append in each file name). the output file will be save to the given
# path 'path_to_save'. the value of options mean:
# c: Clean or non trojan file.
# r: Random trojan insertion.
# bs: Best trojan based straight forward insertion.
# ws: Worst trojan based straight forward insertion.
# exr: Save the change in nw score for random insertion.
# exs: Save the best, worst and mean scores from straight forward insertion.
# bg: Best trojan based greedy insertion.
# wg: Worst trojan based greedy insertion.
# exbg: Save the best and mean scores from greedy insertion.
# exwg: Save the worst and mean scores from greedy insertion.
def generate_and_save_dataset(dataset_gen_utility, hosts, payloads, path_to_save,
                              options=['c'], host_len = 1000, appending_text_in_name = ''):

    available_options = ['c', 'r', 'bs', 'ws', 'exs', 'exr', 'bg', 'wg', 'exbg', 'exwg']
    error_msg = '''
    Invalid option value found. Use from follows:
    c: Clean or non trojan file.
    r: Random trojan insertion.
    bs: Best trojan based straight forward insertion.
    ws: Worst trojan based straight forward insertion.
    exr: Save the change in nw score for random insertion.
    exs: Save the best, worst and mean scores from straight forward insertion.
    bg: Best trojan based greedy insertion.
    wg: Worst trojan based greedy insertion.
    exbg: Save the best and mean scores from greedy insertion.
    exwg: Save the worst and mean scores from greedy insertion.
    '''
    for option in options:
        if option not in available_options:
            print(error_msg)
            exit()

    # creating necessary files
    if 'c' in options:
        f_c = open(path_to_save + 'non_trojan_dataset' + appending_text_in_name + '.txt', 'w')
    if 'r' in options:
        random_insertion = RandInsertion()
        f_r = open(path_to_save + 'random_trojan_insertion_dataset' + appending_text_in_name + '.txt', 'w')
    if any(x in options for x in ['bs', 'ws', 'bg', 'wg', 'exs', 'exbg', 'exwg']):
        nw_insertion = NWbasedInsertion()
    if 'bs' in options:
        f_bs = open(path_to_save+'nw_best_straight_forward_trojan_insertion_dataset'+appending_text_in_name+'.txt', 'w')
    if 'ws' in options:
        f_ws = open(path_to_save+'nw_worst_straight_forward_trojan_insertion_dataset'+appending_text_in_name+'.txt', 'w')
    if 'bg' in options:
        f_bg = open(path_to_save+'nw_best_greedy_trojan_insertion_dataset'+appending_text_in_name+'.txt', 'w')
    if 'wg' in options:
        f_wg = open(path_to_save+'nw_worst_greedy_trojan_insertion_dataset'+appending_text_in_name+'.txt', 'w')
    if 'exr' in options:
        f_exr = open(path_to_save+'random_trojan_insertion_dataset_extra_info'
                          +appending_text_in_name+'.txt', 'w')
    if 'exs' in options:
        f_exs = open(path_to_save+'nw_straight_forward_trojan_insertion_dataset_extra_info'
                          +appending_text_in_name+'.txt', 'w')
    if 'exbg' in options:
        f_exbg = open(path_to_save+'nw_best_greedy_trojan_insertion_dataset_extra_info'
                          +appending_text_in_name+'.txt', 'w')
    if 'exwg' in options:
        f_exwg = open(path_to_save+'nw_worst_greedy_trojan_insertion_dataset_extra_info'
                          +appending_text_in_name+'.txt', 'w')
    # performing insertions according to options and writing results into corresponding files
    for host, payload in zip(hosts[:host_len], payloads):
        payload_DNA_fragments = dataset_gen_utility.get_payload_fragments(payload)
        if 'c' in options:
            f_c.write(host + '\n')
        if any(x in options for x in ['exr', 'r']): 
            seq, nw_change = random_insertion.get_random_insertion(host, payload_DNA_fragments, keep_order=True)
            f_r.write(seq + '\n')
        if 'exr' in options:
            f_exr.write(str(nw_change) + '\n')
        if any(x in options for x in ['bs', 'ws', 'exs']):
            best_seq, worst_seq, best_score, worst_score, avg_score = \
                nw_insertion.get_nw_insertion(host, payload_DNA_fragments, keep_order=True)
        if 'bs' in options:
            f_bs.write(best_seq + '\n')
        if 'ws' in options:
            f_ws.write(worst_seq + '\n')
        if 'exs' in options:
            f_exs.write(str(best_score) + ',' + str(worst_score) + ',' + str(avg_score) + '\n')
        if any(x in options for x in ['bg', 'exbg']):
            best_seq_greedy, best_score_greedy, avg_best_score_greedy = \
                nw_insertion.get_nw_insertion_greedy(host, payload_DNA_fragments, return_best=True)
        if 'bg' in options:
            f_bg.write(best_seq_greedy + '\n')
        if 'exbg' in options:
            f_exbg.write(str(best_score_greedy) + ',' + str(avg_best_score_greedy) + '\n')
        if any(x in options for x in ['wg', 'exwg']):
            worst_seq_greedy, worst_score_greedy, avg_worst_score_greedy = \
                nw_insertion.get_nw_insertion_greedy(host, payload_DNA_fragments, return_best=False)
        if 'wg' in options:
            f_wg.write(worst_seq_greedy + '\n')
        if 'exwg' in options:
            f_exwg.write(str(worst_score_greedy) + ',' + str(avg_worst_score_greedy) + '\n')
    # closing files
    if 'c' in options: f_c.close()
    if 'r' in options: f_r.close()
    if 'bs' in options: f_bs.close()
    if 'ws' in options: f_ws.close()
    if 'bg' in options: f_bg.close()
    if 'wg' in options: f_wg.close()
    if 'exs' in options: f_exs.close()
    if 'exr' in options: f_exr.close()
    if 'exbg' in options: f_exbg.close()
    if 'exwg' in options: f_exwg.close()



def main(hosts, payloads, fragment_len, number_of_set, dataset_path, retain_pos=0, encryption_key=0, host_len = 1000, number_of_host=1000):
    dataset_path += 'fragment_len_{}/retention_pos_{}/encryption_key_{}/'.format(fragment_len, retain_pos, encryption_key)
    os.makedirs(dataset_path, exist_ok=True)
    utility = GenerateDataSetUtility(start_tag='TCATG', end_tag='GTTGG',
                                     fragment_len=fragment_len, retain_pos=retain_pos, encryption_key=encryption_key)
    for dataset_num in range(0, number_of_set):
        path_to_save = dataset_path+'dataset_'+str(dataset_num)+'/'
        os.makedirs(path_to_save, exist_ok=True)
        options = ['c', 'r', 'bs', 'ws', 'exs', 'exr', 'bg', 'wg', 'exbg', 'exwg']
        appending_text_in_name = ''
        # collecting random hosts
        rand_hosts = random.sample(hosts, number_of_host)
        generate_and_save_dataset(utility, rand_hosts,
                                payloads, path_to_save, options, host_len, appending_text_in_name)


if __name__ == '__main__':
    dataset_path = './experiment_data/datasets/'
    os.makedirs(dataset_path, exist_ok=True)
    fragment_lengths = [1, 2, 3, 4, 5]
    retention_numbers = [0, 1, 2, 3, 4, 5]
    encryption_keys = [0, 10, 20, 30, 40, 50]
    number_of_set = 10
    host_len = 1000
    number_of_host = 1000
    utility = GenerateDataSetUtility()
    hosts = utility.get_lines_from_a_file('./experiment_data/seed_data/hosts.txt')
    payloads = utility.get_lines_from_a_file('./experiment_data/seed_data/payloads.txt')
    payloads = utility.make_shorter_payloads(payloads)
    for fragment_len in fragment_lengths:
        for retain_pos in retention_numbers:
            for encryption_key in encryption_keys:
                main(hosts, payloads, fragment_len, number_of_set, dataset_path, retain_pos, encryption_key, host_len, number_of_host)

