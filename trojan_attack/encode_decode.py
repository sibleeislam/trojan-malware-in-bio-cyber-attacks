import re

class EncodeDecode():

    def __init__(self, start_tag='ACTG', end_tag='ACTG', retain_pos = 0):
        start_tag_regex = ""
        for c in start_tag:
            for i in range(0, retain_pos):
                start_tag_regex += '[ACTGN]'
            start_tag_regex += c
        start_tag_regex = r"" + start_tag_regex + ""

        end_tag_regex = ""
        for c in end_tag:
            for i in range(0, retain_pos):
                end_tag_regex += '[ACTGN]'
            end_tag_regex += c
        end_tag_regex = r"" + end_tag_regex + ""

        self.start_tag = start_tag
        self.end_tag = end_tag
        self.start_tag_pattern = re.compile(start_tag_regex)
        self.end_tag_pattern = re.compile(end_tag_regex)
        self.retain_pos = retain_pos
        self.order_to_n_mapping = {0:'AA', 1:'AC', 2:'AG', 3:'AT', 4:'CA', 5:'CC', 6:'CG',
                              7:'CT', 8:'GA', 9:'GC', 10:'GG', 11:'GT', 12:'TA', 13:'TC', 14:'TG', 15:'TT'}
        self.n_to_order_mapping = dict((v,k) for k,v in self.order_to_n_mapping.items())

    # simple message encoding, text into DNA
    def encode(self, secretMessage):
        # convert secretMessage into binary
        a_bytes = bytes(secretMessage, "ascii")
        binaryArray = []
        for byte in a_bytes:
            binaryArray.append("{0:b}".format(byte).rjust(8,'0'))
        binaryFakeDNA = ''.join(binaryArray)

        # using dictionary convert cover dna to binary
        dnaDictionary = {'A':'00', 'C':'01', 'G':'10', 'T':'11'}
        reverseDnaDictionary = dict((v,k) for k,v in dnaDictionary.items())
        fakeDNA = ""
        for i in range(0, len(binaryFakeDNA), 2):
            fakeDNA += reverseDnaDictionary[binaryFakeDNA[i:i+2]]
        return fakeDNA

    # simple message decoding, DNA into text
    def decode(self, fakeDNA):
        # convert fake dna to binary using dictionary
        dnaDictionary = {'A':'00', 'C':'01', 'G':'10', 'T':'11'}
        binaryOfFakeDNA = ""
        for base in fakeDNA:
            binaryOfFakeDNA += dnaDictionary[base]
        # convert binary to ascii and reveal message
        bytes = [binaryOfFakeDNA[i:i+8] for i in range(0, len(binaryOfFakeDNA), 8)]
        decodeMessage = ""
        for byte in bytes:
            decodeMessage += chr(int(byte, 2))
        bases = ['A', 'C', 'T', 'G']
        # return bases[random.randint(0,3)]+decodeMessage+bases[random.randint(0,3)]
        return decodeMessage

    # perform xor operations (used for encryption and decryption)
    def xor(self, a, b):
        if len(a) != len(b) and len(a) != 8:
            print('Either size mismatch for XOR, or the values is not 8 bit')
            exit()
        y = int(a, 2) ^ int(b, 2)
        return '{0:b}'.format(y).rjust(8, '0')

    # message encrypted encoding, text and order number into DNA (applying encryption)
    ## msg_fragment(text), order_num(int), key(int)
    def fragment_encrypted_encode(self, msg_fragment, order_num, key=60):
        dna_dictionary = {'A': '00', 'C': '01', 'G': '10', 'T': '11'}
        reverse_dna_dictionary = dict((v, k) for k, v in dna_dictionary.items())
        # convert string and key into binary
        binary_msg = ["{0:b}".format(ord(ch)).rjust(8, '0') for ch in msg_fragment]
        binary_order = ['0000'+''.join([dna_dictionary[n] for n in self.order_to_n_mapping[order_num]])]
        binary_key = "{0:b}".format(key).rjust(8, '0')
        binary_msg = binary_order + (binary_msg)
        encrypted_binary = [self.xor(binary_ch,binary_key) for binary_ch in binary_msg[::-1]][::-1]
        encrypted_binary = ''.join(encrypted_binary)[4:]
        encrypted_msg_fragment = ''.join([reverse_dna_dictionary[bits] for bits in re.findall('..',encrypted_binary)])
        return encrypted_msg_fragment

    # message decrypted decoding, DNA into order number and text (applying decryption)
    def fragment_decrypt_decode(self, encrypted_msg_fragment, key=60):
        dna_dictionary = {'A': '00', 'C': '01', 'G': '10', 'T': '11'}
        reverse_dna_dictionary = dict((v, k) for k, v in dna_dictionary.items())
        binary_key = "{0:b}".format(key).rjust(8, '0')
        encrypted_binary = re.findall('........','0000'+''.
                                      join([dna_dictionary[n] for n in encrypted_msg_fragment]))
        decrypted_binary = ''.join([self.xor(binary_ch,binary_key) for binary_ch in encrypted_binary[::-1]][::-1])
        decrypted_binary = decrypted_binary[4:]
        decrypted_dna_string = ''.join([reverse_dna_dictionary[bits] for bits in re.findall('..', decrypted_binary)])
        order = self.n_to_order_mapping[decrypted_dna_string[:2]]
        msg = self.decode(decrypted_dna_string[2:])
        return order, msg

    # called by make_payload function. make all the fragments of the message, encode and return
    def make_fragments(self, msg, fragment_size, encrypted=False, key=60):
        pattern = '.{1,'+str(fragment_size)+'}'
        for_retention = ''.join(['X' for i in range(self.retain_pos)])
        fragments = re.findall(pattern, msg)
        if encrypted:
            fragments = [self.fragment_encrypted_encode(fragments[i], i, key) for i in range(len(fragments))]
        else:
            fragments = [self.order_to_n_mapping[i]+self.encode(fragments[i]) for i in range(len(fragments))]
        fragments = [self.start_tag + fragment + self.end_tag for fragment in fragments]
        fragments = [''.join([for_retention+c for c in list(fragment)]) for fragment in fragments]
        return fragments

    # make the encode fragments using get_fragments function, combine and makes the payload
    def make_payload(self, msg, fragment_size, encrypted=False, cover_dna='', key=60):
        fragments = self.make_fragments(msg, fragment_size, encrypted, key)
        payload = ''.join(fragments)
        if self.retain_pos == 0:
            return payload
        if len(cover_dna) != len(payload):
            print('Error: Encoding decoding only accepts same length of cover DNA and payload DNA')
            exit()
        payload = ''.join([cover_c if payload_c=='X' else payload_c
                           for cover_c, payload_c  in zip(list(cover_dna), list(payload))])
        return payload

    # called by get_payload function. get all the fragments available in a message, decode and return
    def get_fragments(self, input, encrypted=False, key=60):
        fragments = {}
        while True:
            match = re.search(self.start_tag_pattern, input)
            if match is None:
                break
            input = input[match.end():]
            match = re.search(self.end_tag_pattern, input)
            if match is None or match.start() == 0:
                break
            fragment = input[0: match.start()]
            order_num = ''.\
                join\
                ([fragment[i] for i in range(self.retain_pos, 2+2*self.retain_pos, self.retain_pos+1)])
            fragment = fragment[2+2*self.retain_pos:]
            msg = ''.\
                join\
                ([fragment[i] for i in range(self.retain_pos, len(fragment), self.retain_pos+1)])

            if encrypted:
                order_num, msg = self.fragment_decrypt_decode(order_num + msg, key)
                order_num = self.order_to_n_mapping[order_num]
            else:
                msg = self.decode(msg)

            fragments[order_num] = msg
            input = input[match.end():]

        return fragments

    # get the decoded fragments using get_fragments function, combine and retrieve the message
    def get_payload(self, input_DNA_sequence, encrypted=False, key=60):
        payload = ''
        fragments = self.get_fragments(input_DNA_sequence, encrypted, key)
        #decript will go here
        fragments = {self.n_to_order_mapping[key]:value for key,value in fragments.items()}
        fragments = sorted(fragments.items())
        payload = ''.join([msg for i, msg in fragments])
        return payload

# endcode_decode = EncodeDecode(retain_pos=0)
# # print(endcode_decode.encode('Hello'))
# # print(endcode_decode.decode('CAGACGCCCGTACGTACGTT'))
# print(len('ACTGCCCAGACGCCCGTACGTACGTTACTGGACTGCCCAGACGCCCGTACGTACGTTACTG'))
# print(endcode_decode.get_payload('ACTGCCCAGACGCCCGTACGTACGTTACTGGACTGCACAGACGCCCGTACGTACGTTACTG'))
# print(len(endcode_decode.encode("Hello"))+2)
# print(endcode_decode.fragment_encrypted_encode("Hello",5))
# print(endcode_decode.fragment_decrypt_decode('GCCTCACCGCCCAACCAACCAT'))

# endcode_decode = EncodeDecode(retain_pos=2)
# x = ['XXAXXCXXTXXGXXAXXAXXCXXAXXGXXAXXCXXGXXCXXCXXAXXCXXTXXG', 'XXAXXCXXTXXGXXAXXCXXCXXGXXTXXAXXCXXGXXTXXAXXAXXCXXTXXG', 'XXAXXCXXTXXGXXAXXGXXCXXGXXTXXTXXAXXGXXAXXAXXAXXCXXTXXG', 'XXAXXCXXTXXGXXAXXTXXCXXTXXCXXTXXCXXGXXTXXTXXAXXCXXTXXG', 'XXAXXCXXTXXGXXCXXAXXCXXTXXAXXGXXCXXGXXTXXAXXAXXCXXTXXG', 'XXAXXCXXTXXGXXCXXCXXCXXGXXCXXAXXAXXCXXTXXG']
# x = ''.join(x)
# x = x.replace('X', 'A')
# print(x)
# print(endcode_decode.get_payload(x))
